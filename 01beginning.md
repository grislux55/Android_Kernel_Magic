# 一、入门简介

`注意！！！由于本文主要探讨Android内核，因此后续文字如不额外说明，均认为内核指代的是Android内核！！！`

## 介绍

### 一、内核的概念

* 问题一：

  > 内核是啥？

* 解答：

  > 内核，是Android系统中贴近底层（或者说就是底层）的一个组件。它就像汽车的基础框架，铅笔的芯，大楼的地基。内核为整个操作系统提供了直接的硬件交互能力，也为操作系统提供了大量的资源调度的能力，既可以为上层应用分配资源，也可以限制上层应用的资源。

* 问题二：

  > 为什么要修改内核？

* 解答：

  > 因为内核可以对进程、网络、内存、磁盘等多个方面进行控制，所以内核的优化程度的高低可以一定程度上影响性能。这些资源的控制和分配的过程我们将其称之为“调度策略”，或者是“[算法](https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95)”——这些策略决定了我们机器上每一个软件所能分配到的资源量。如果能将这些调度策略变得更优更精简更快，那么也就意味着我们的手机能够跑得更快、更省电。

* 问题三：

  > 既然内核有这么重要的作用，那为什么官方不优化好呢？

* 解答：

  > 实际上，大部分厂商确实会尝试对内核进行一定程度上的优化，但是这些优化确确实实是良莠不齐的。并不是说官方的程序员就比这些自由的开发者技术会更差，事实上正如每一个人都有他的优点和缺点一样，不同厂商、个人在内核里面引入的技术好坏程度也不尽相同。而且世界也不是非黑既白的，在某一场景下的正确措施，却可能会掣肘另一个情景。
  >
  > 比如说文件在写入磁盘前会被提前放在系统中的某个区域，这块区域被称为磁盘缓存，这块地方一般存在于内存之中，用于把大量的小文件整合成一大块，最后再一起放入硬盘，就不会因为频繁的硬盘存取而减慢速度。这听起来很美好，但是实际上呢？如果我写入一个非常大的文件，文件就会被放在内存里面再放进硬盘里面，与直接放进硬盘里面来说完全多了一次复制的过程，那么文件的写入相对来说就变慢了。而且这项技术还有更多的问题：内存是不稳定的，我断电之后缓存下来的东西就已经消失了，那这些数据怎么办？针对这些情况内核的处理又有更多的思路，比如说DirectIO——绕过缓存直接读写硬盘。那么这种新的思路也显然算某种意义上的优化。那添加了DirectIO之后又会出现什么问题呢？这就需要更多的考量。
  >
  > 同样的，考虑到内核里面大量的支持不同平台的代码，不同的平台又有不同的调度策略，如果能对我们自己使用的平台进行仔细的定制与调校，那么的确是有机会比**厂商官方**优化得更好的。

* 问题四：

  > 第三方内核一定就比官方好吗？

* 解答：

  > 当然......不是。第三方的内核从理论上来说并不存在总是优化的情况。这一点主要和**维护**（不是制作！）这个内核的开发者的理念与代码熟悉程度有关。

### 二、编译器有关的概念

* 问题一：

  > 什么是GCC，什么是Clang，它们之间有什么区别？

* 解答：

  > GCC和Clang只是我们使用的工具里面的一部分（GCC是GNU Compiler Collection的一部分，Clang是LLVM项目的一部分），它们负责将内核中的C语言代码转换成下一步要使用的码元（针对不同的情况，它们输出的内容可以是不同的，比如说GCC可以直接输出机器码，也可以输出GNU Compiler套件自己定义的中间码）。
  >
  > 对于我们来说，它们之间最大的区别在于GCC编译器区分平台打包，编译时需要使用对应平台的编译器；Clang编译器本身不分平台打包，而是在编译时使用-target指定平台。Google官方目前墙裂推荐将Clang作为Android项目的编译器。

* 问题二：

  > 什么是交叉编译工具链？

* 解答：

  > 交叉编译工具链是在一个平台上编译输出另一个平台上应用程序的一整套工具（不只是编译器，还有很多其他工具）。（值得注意的是，虽然Android也是一种Linux，但是因为芯片的不同，所以这也属于跨平台。）

* 问题三：

  > GCC和Clang的性能有什么区别吗？

* 解答：

  > 当然有区别，Clang编译套件是组件化的，由Clang编译器前端分发优化下的LLVM IR，再由LLVM后端进行更细致的优化处理，最终生成汇编。GCC内部则是直接生成到汇编。所以GCC的编译时占用通常要比Clang的要高，当然，凡事也没有个绝对，当Clang开启LTO（链接时优化）的时候，因为要读入所有的LLVM IR，所以占用会达到一个惊人的数值。对于生成的代码，其性能在不同的情况下有着不同的表现，一般情况下的Clang直接编译的性能是比不上GCC的，但是开启LTO，polly之类的优化之后又能略微超出。

* 问题四：

  > 那推荐使用哪个编译器呢？

* 解答：

  > 仁者见仁智者见智，由于Clang的软件分发的方式，有时会破坏掉内核代码的生成；GCC编译内核时产出的警告则比较多，不利于查看输出。两者使用的方式是大同小异的，两个编译器之间也没有分出一个确切的高下，双方也没有杀手锏可以稳压对方，随着时间的推进，两个编译器也都是在不断进化的。所以这里不给出推荐，如果您之前使用过这两者之中的任一个，建议保持原样。

